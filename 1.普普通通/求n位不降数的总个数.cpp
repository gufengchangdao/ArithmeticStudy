//求n位数的不降数个数 
#include<bits/stdc++.h>
using namespace std;
int f[3][11];//f[0][j]为上一位末尾数为j的总数，f[1][j]为当前位末尾数为j的总数
int main()
{
	int n;
	scanf("%d",&n);
	n=n%100019;//这里给了n为10^8的取值范围，还要对100019取模，这里不取会超时 
	for(int i=1;i<=9;i++) f[0][i]=i; 
	for(int i=2;i<=n;i++){//遍历n位 
		for(int j=1;j<=9;j++){//对第n位数遍历一遍 
			f[1][j]=(f[1][j-1]+f[0][j])%100019;
						//比如j=5,f[1][5]=f[1][4]+f[0][5]，前一位为5的情况有f[0][5]种，加上本位不为5有f[1][4]种 
			f[0][j]=f[1][j];//每一位f[0][j]只会遍历一次，可以现在就保存值了 
		}
	}
	printf("%d\n",f[0][9]);
}
//我真是个天才 
