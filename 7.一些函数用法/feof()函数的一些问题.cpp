EOF是文本文件结束的标志,EOF的16进制代码为0xFF（十进制为-1），因此可以用EOF作为文件结束标志
二进制文件没有-1，文本文件和二进制文件都可以用feof() 
1.
fgetc()读取文件的最后一个字符以后，C语言的feof()函数依然返回0，表明没有到达文件结尾；只有当fgetc()向后再读取一个字符（即越过最后一个字符），feof()才会返回一个非零值，表示到达文件结尾。
所以，按照上面这样写法，如果一个文件含有n个字符，那么while循环的内部操作会运行n+1次。
while(!feof(fp)){
		//因为不能完全依赖feof判断文件是否到结尾，所以用fgetc的返回值来判断，
		//这里用fgetc继续读取一个字符，来判断是否结束
		//如果不是-1（结尾），那么回退一个文件位置到读取字符前的位置，如果是-1，退出
		c = fgetc(fp);
		if (c != -1)//用-1判断，所以这是文本文件的 
			fseek(fp, -1, 1);
		else break;
...
}
2.
while(!feof(fp)){
	int a=fscanf(  );
	if(a==-1) break;//fscanf返回的是实际读取的数据个数，出错或者到结尾返回EOF
	...
}
3.
while(!feof(fp)){
	int a=fread()
	if(a==0) break;//返回0表示读取数量不够size字节，究竟是多少不知道
	...
}
4.
注意：feof判断文件结束是通过读取函数fread/fscanf等返回错误来识别的，故而判断文件是否结束应该是在
	读取函数之后进行判断。比如，在while循环读取一个文件时，如果是在读取函数之前进行判断，则如果文件
	最后一行是空白行，可能会造成内存错误。
int a=fread(&log,size,1,fp);课本上采用的，先读入一个，每次在循环末尾才再读入一个 
while(!feof(fp)){
	... 
	fread(&log,size,1,fp);
}
5.
用fwrite写入的文本文件或者二进制文件，可以用除法求数据块的个数 
fseek(fp,0,2);//指针指到末尾 
int count=ftell(fp)/size;//计算数据块的个数 
for(int i=0;i<count;i++){
	//读取 
	...
}
