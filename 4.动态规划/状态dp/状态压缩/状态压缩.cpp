状态压缩： 
当状态维数很多，但总量很少时，可以将状态压缩为一个数来记录。
	如果状态的够成非常多，但每个构成相对简单，就可以状态压缩，例如，0<=a,b,c<N，N表示a,b,c有N种状态 
	存储为num[i]的数组 
	直接储存为abc的十进制形式 
	也可以转化为N进制的形式表示，sum=a*N^2+b*N^1+c*N^0;
		具体看cpp:  状态压缩 k种状态用10进制存储方式 
	
	一般物体只有两种状态且数据量小，可以用二进制的形式表示 
		适用位运算进行	状态转移、检测某一位状态
			(矩阵可以检测每一行的合法性，合法的时候求出该种序列的值，遍历的时候一行一行遍历) 
		for(int i=0;i<n;i++) if(sum&(1<<i)) ans++; 可以用来检测sum中有多少个1 
		i<=26用int存	 		26 67108864 8位 
		i<=59用long long 存		56 72057594037927936 17位 
		获得第i位的数据，判断sum&(1<<(i-1)) 
		设置第i位为1，sum|=(1<<(i-1));  
		设置第i位为0，sum&=(~(1<<i-1));
		将第i位取反，sum=(sum^(1<<i-1)); 
		取出一个数的最后一个1 sum=(sum&(-sum)); 
								（利用负数取反加1,负数的补码等于对应的正数二进制表示取反加1）
		具体看cpp: 位运算 
		
	作为一种数字排列时，用康托判重	

关于状态dp的dp[]
	求最大值时，初始化为0
	求最小值时，初始化为最大值，但要注意动态规划的初始条件，有时dp[0]=0 





