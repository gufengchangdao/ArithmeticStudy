区间最值操作:
	[l,r]与x,进行max(A[i],x)、min(A[i],x)操作
	
struct node{
	int l,r,num,
	mx,se,cnt;mx为区间最大值、se为严格次最大值、cnt为最大值个数 
}; 

对区间[l,r]每个数a[i]=min(a[i],x);
 	先在线段树中定位这个区间，对定位的每个结点，开始暴力搜索，对于每个结点 
 		当mx<=x时，不用修改，退出
		当se<x<mx时，只用修改所有最大值，num+cntt*(x-mx)，x-mx是个负数，为差值，把max更新为x，打上标记，退出
		当se>=x时，无法判断，对左右儿子进行递归搜索 ，等于也不可以，因为次最大值有多少不知 
		
 	我们把最大值看成标记，每一个结点记录一个标记值，如果一个点的标记值和他父亲的标记值相同，我们就把
	这个位置的标记删去，在转化后，线段树最多存在n个标记，每一个结点的标记值都大于中的所有标记的值
	(因为有些子树标记值删去)。而我们维护的区间次大值相当于子树中标记的最大值 

	我们发现这种方法的本质是把线段树上每个节点维护的元素分成了最大值和非最大值这两类，
并对它们分别维护。区间最大值标记只会打在 se<v<mx 的节点上，可以看成只针对最大值的加减操作；
而区间加操作对于这两类值都生效。分别维护区间最大值的加减标记和非最大值的加减标记，下传时判断当前
节点是否为区间最大值即可。
 	
 	
 	
 	
