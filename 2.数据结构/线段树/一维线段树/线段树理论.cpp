日拱一卒,功不唐捐

懒标记种类
	 最值：	   mx 		mn		mx2		mn2		mxt		mnt
 历史最值：	   mx_ 		mn_		mx2_	mn2_				历史最值 
	 		   最大		最小	次大	次小	最大个数 最小个数 
	运算标记 tag 	cov		add1	add2	add3	mul		...
					cov_	add1_ 	add2_	add3_	mul_	历史最值标记 
		  是否覆盖 覆盖值  最大值  最小值   其他值  乘法 

void pushup(int o)状态合并 
	由子树数据更新父结点，除了运算标记、l、r,其他的都更新 
	有最值时，要讨论最值来自哪个子树 
	
void update(int o, int k1, int k1_, int k2, int k2_,int k3,int k3_)更新数据
	下传标记，要先判断标记是否存在，子树使用父亲的标记，使用完父亲的标记后要初始化 
	含有历史最值时，先更新历史最值再更新最值，因为前者需要用到原来的最值 
	同时有最大、小值时，先if判断最值个数情况，次值是否等于最值，解决数域重叠问题 
	更新次值的时候要先判断一下是否存在次值
	有覆盖操作时， 要判断是否有覆盖标记，要分部讨论
	同时存在加减k1、乘法标记k2时，更新方法：加法=加法*k2+k1,乘法=乘法*k2  

void down(int k)下传标记 
	
void build(int o, int l, int r, int* a)建树 
	值和标记的初始化、次值要初始为最大、最小值
	 
void cover(int o, int k, int k_)//区间覆盖 
	更改完最值信息、标记、历史最大、最大标记值，还要tag标记 
	
int queryQ(int o, int l, int r)查询操作 
void updateP(int o, int l, int r, int k)更新操作 
	1. 判断：是否找到有效区间(叶子结点、子区间)、无效区间(跑到所需区间外了),处理并返回 
	2. 懒标记下传：判断之后下传 
	3. 查找：(判断之后)查找左右子结点 
	4. 状态合并：每次修改完子结点后就要更新父节点信息，信息量大可以装进函数里 
	
	存在最值时，对于修改操作只修改最值，分情况讨论 


1、线段树是一棵二叉搜索树，它储存的是一个区间的信息。
2、每个节点以结构体的方式存储，结构体包含以下几个信息：
    区间左端点、右端点；（这两者必有）
    这个区间要维护的信息（事实际情况而定，数目不等）。
3、线段树的基本思想：二分。

1、每个节点的左孩子区间范围为[l，mid]，右孩子为[mid+1,r]
2、对于结点k，左孩子结点为2*k，右孩子为2*k+1，这符合完全二叉树的性质

对于区间求和 
struct node
{
       int l,r,w;//l，r分别表示区间左右端点，w表示区间和
}tree[4*n+1];结构体要开4倍空间 

线段树的基础操作主要有5个：
建树、单点查询、单点修改、区间查询、区间修改。

建树： 
	主体思路：对于二分到的每一个结点，给它的左右端点确定范围。
            如果是叶子节点，存储要维护的信息。
            状态合并。
void build(int l,int r,int k)
{
    tree[k].l=l;tree[k].r=r;
    if(l==r)//叶子节点，每次到了叶子结点就不再更新 
    {
        scanf("%d",&tree[k].w);这里可以改为赋值 
        return ; 
    }
    int m=(l+r)>>1;
    build(l,m,k*2);//左孩子 
    build(m+1,r,k*2+1);//右孩子 
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//状态合并，此结点的w=两个孩子的w之和
										//状态合并这个位置放得刚刚好，子树已经赋好值 
}

单点查询，即查询一个点的状态，设待查询点为x
	主体思路：与二分查询法基本一致，如果当前枚举的点左右端点相等，即叶子节点，就是目标节点。如果
	不是，因为这是二分法,所以设查询位置为x，当前结点区间范围为了l，r，中点为mid，则如果x<=mid，则
	递归它的左孩子，否则递归它的右孩子
void ask(int k)//查找k下标对应的值，每一个结点都有左右区间 
{
    if(tree[k].l==tree[k].r) //当前结点的左右端点相等，是叶子节点，是最终答案 
    {
        ans=tree[k].w;
        return ;
    }
    //if(tree[k].f) down(k);//懒标记下传
    int m=(tree[k].l+tree[k].r)>>1;
    if(x<=m) ask(k*2);//目标位置比中点靠左，就递归左孩子 
    else ask(k*2+1);//反之，递归右孩子 
}

单点修改，即更改某一个点的状态。用引例中的例子，对第x个数加上y
	主体思路：找到x的位置；根据建树状态合并的原理，修改每个结点的状态。	
void add(int k)
{
    if(tree[k].l==tree[k].r)//找到目标位置 
    {
        tree[k].w+=y;//y为修改值 
        return;
    }
    //if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)>>1;
    if(x<=m) add(k*2);
//    if(x<=m){既可以找到叶子结点更新后，由下往上更新父结点，也可以遍历的时候直接更新 
//    	tree[k].w+=y;
//		add(k*2);	
//	}
    else add(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//所有包含结点k的结点状态更新,由叶子结点引发的父结点都更新 
}
区间查询，即查询一段区间的状态，在引例中为查询区间[x,y]的和
	主体思路：对于当前区间[l,r]，由根结点[1,n]开始，因此待查区间一定在根区间中
	y<=mid，查询区间全在左，x>mid，查询区间全在右，否则，查询区间两边都在，即两个子区间都走
	当[l,r]含于[x,y]时直接加上当前值	 
void sum(int k)
{
	//if(k>n*4) return;既可以根据结点下标剪枝，又可以根据结点的区间剪枝，毕竟 x>0,无效数据的l=0，不可能记录进去 
	if(y<tree[k].l || tree[k].r<x) return;
    if(tree[k].l>=x&&tree[k].r<=y)//找到查询区间或其一部分，加上值后返回 
    {
        ans+=tree[k].w;
        return;
    }
    //if(tree[k].f) down(k);//懒标记下传
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) sum(k*2);左右都要判断，因为在mid中间时都要左右查询 
    if(y>m) sum(k*2+1);
}

区间修改，即修改一段连续区间的值，我们已给区间[a,b]的每个数都加x为例讲解
	对每个叶子结点修改，但是查询的区间用不上就会非常浪费，引入“懒标记”
	存储到这个节点的修改信息，暂时不把修改信息传到子节点。 
	a.原结构体中增加新的变量，存储这个懒标记。
    b.递归到这个节点时，只更新这个节点的状态，并把当前的更改值累积到标记中。注意是累积
    c.当需要递归这个节点的子节点时，标记下传给子节点。这里不必管用哪个子节点，两个都传下去。
    3部分：当前节点的懒标记累积到子节点的懒标记中。
    修改子节点状态。在引例中，就是原状态+子节点区间点的个数*父节点传下来的懒标记。
    既然父节点都把标记传下来了，为什么还要乘父节点的懒标记，乘自己的不行吗？
    因为自己的标记可能是父节点多次传下来的累积，每次都乘自己的懒标记造成重复累积
    父节点懒标记清0。这个懒标记已经传下去了，不清0后面再用这个懒标记时会重复下传。
    对每个区间加一个懒标记，标志着这个区间是否进行了修改，如果进行了，那么它的子区间也要进行
	修改，并且把懒标记转给子结点（因为子结点的子区间也要修改）
void down(int k)
{
    tree[k*2].f+=tree[k].f;//懒标记传给两儿子 
    tree[k*2+1].f+=tree[k].f;
    tree[k*2].w+=tree[k].f*(tree[k*2].r-tree[k*2].l+1);//修改区间值 
    tree[k*2+1].w+=tree[k].f*(tree[k*2+1].r-tree[k*2+1].l+1);
    tree[k].f=0;//父亲不需要懒标记了 
}
void add(int k)//[a,b]+x
{
	//if(k>n*4) return;既可以根据结点下标剪枝，又可以根据结点的区间剪枝，毕竟 x>0,无效数据的l=0，不可能记录进去 
	if(y<tree[k].l || tree[k].r<x) return;
    if(tree[k].l>=a&&tree[k].r<=b)//当前区间全部对要修改的区间有用，把该区间看做儿子
    {
        tree[k].w+=(tree[k].r-tree[k].l+1)*x;//(r-1)+1区间点的总数
        tree[k].f+=x;//相当于叶子结点结点也更新懒标记 
        return;
    }
    if(tree[k].f) down(k);//懒标记下传,只有不满足上面的if条件才执行,所以一定会用到当前节点的子节点 
    	//存在懒标记就下传 
    int m=(tree[k].l+tree[k].r)/2;
    if(a<=m) add(k*2);
    if(b>m) add(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//更改区间状态 
}
	
空间优化：
	根左右的顺序存储下标(就是dfs的遍历次序当做它的下标)，能省一半 
	结构体中不存储左右结点，换而在递归函数中作为参数遍历，省空间耗时间 
	zkw线段树(还不会)
		
	 
