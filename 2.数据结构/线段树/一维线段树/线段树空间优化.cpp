传统的写法是：
根结点：A 
A的左子结点：2A（写成A<<1）
A的右子结点：2A+1（写成(A<<1)+1）
这种表示法可以表示出整棵线段树，因为：
（1）每个结点的子结点的下标都比它大，这样就不会出现环；
（2）每个结点的父结点都是唯一的（其本身下标整除2）；
但是，这种表示法有一个弱点：结点的下标是有可能超过2N的，但不会超过4N，因此，为了表示出跨度为N的线段，
我们需要开4N的空间，然而，其中只有2N-1个位置是有用的（因为表示跨度为N的线段的线段树共有(2N-1)个结点），这样，就有一半的空间被浪费。尤其是这种线段树推广到多维的时候――K维线段树就只有1/2K的位置是有用的，空间利用率非常低。在某些卡空间的场合，它就宓袅恕
优化代码：
int mid=(l+r)>>1;
build(l, mid, A+1);
build(mid+1, r, (r-l&1?A+r-l+1:A+r-l+2));		//	r-l是奇数：r-l+1+A 
											//	r-l是偶数：r-l+2+A  
int mid=(l+r)>>1;
build(l, mid, A+1);
build(mid+1, r, A+r-l+2-((r^l)&1));

int mid=(l+r)>>1;
build(l, mid, A+1);
build(mid+1, r,A+e[k+1].sum*2);//e[k+1].sum为左孩子的区间长度，等于mid-l+1 

inline void build(int l,int r)第三种方法建树时 
{
    cnt++;
    e[cnt].l=l;e[cnt].r=r;
    e[cnt].sum=r-l+1;	//sum表示区间长度 
    if(l==r) return;
    int mid=l+r>>1;
    build(l,mid);build(mid+1,r);
} 
牺牲一些时间，将线段树下标的空间利用率提高到了100%，以后只需要开2N空间就行了
这种写法就是――直接将每个结点的DFS遍历次序当做它的下标！！类似根 左 右的顺序为下标 
比如，跨度为6的线段树：
   	  1
    2    7					
  3  6  8  11
 4 5   9 10
推理： 
若A的左右端点为l、r，mid=(l+r)/2（下取整），
则A的左子树所表示的线段为[l, mid]，所以	
	SZ(A.L)=(mid-l+1)*2-1=(mid-l)*2+1=((r-l-1)/2（上取整）)*2+1
A的右子结点下标就是A+((r-l+1)/2（上取整))*2，也就是A加上大于(r-l)的最小的偶数； 
 
