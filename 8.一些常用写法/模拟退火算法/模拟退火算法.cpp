模拟退火算法：
	适用于函数最值问题、TSP旅行商问题、最小圆覆盖、最小球覆盖等
	 
在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为：P(dE) = exp( dE/(kT) )
dE为能量差，dE<0，所以dE/(kT)<0 ，所以P(dE)取值范围为(0,1) 
T越大， dE/(kT)越趋于0，降温概率越大，T越小，降温概率越小
接受差解的可能性更大 随着时间推移，T减小，接受差解的可能性更小
	 
开始时，T设为一个较大的值，此时接受质量差的解的概率大，使得有较多的机会跳离局部最优，这时内层循环
	类似于一个单纯的随机搜索。然后逐渐减小T值，使得接受质量差的解的概率越来越小，接受质量好的解的
	概率越来越大。到算法结束时，T值变得很小，使得模拟退火的最后阶段类似于普通的爬山法：如果新解比
	当前解更好，则总是接受它。

模拟退火算法在实现时，要确定四个特殊的条件：
	（1）初始“温度”T的值是多少？初始温度T=1000，100还是其它值呢？
	（2）每个温度要迭代多少次才降温一次？温度应衰减多少次或者多大因子？是每次减少5，还是%1？
	（3）如何选取终止条件？是执行一定数目的迭代还是使用其它规则？ 
	（4）如何选择停机条件，即“凝固”温度是多少？
	
const double T=        //初始温度T,系统初始应该要处于一个高温的状态       
const double eps=1e-8;	//终止温度 ,若温度T达到eps，则停止搜索 
double delta=0.98;		//退火系数
const int L=1000;  // 每个温度时的迭代次数，即链长 
//伪代码 
while(T>eps)
{
	for(int i=0;i<cnt;i++){
		//产生新解y(i+1),求出f(y(i+1)) 
		double de=f(y(i+1))-f(y(i));	//求出能量差
		ans=min(ans,f(y(i+1))); 
		if(de>=0){//更新y(i)的情况：更优解、有概率的差解	 
			y(i+1)=y(i);				//注意 exp()中必须为负数，rand()%RAND_MAX得到0~1的概率数 
		}
		else if(exp(-de/T)>rand()%RAND_MAX){
			y(i+1)=y(i);	
		}	
	}
	T*=delta;//降温退火 ，0<r<1 。r越大，降温越慢；r越小，降温越快
//若delta过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值
	count++;
}

如果满足最终的终止条件，Stop，则输出当前解S1作为最优解，结束程序。
	终止条件Stop通常为：在连续若干个Metropolis链中新解S2都没有被接受时终止算法，
						或者是设定结束温度。否则按衰减函数衰减T后继续计算
	也可以多次模拟退火，但防止T了，for(int i=0;i<100;i++) sa();  
