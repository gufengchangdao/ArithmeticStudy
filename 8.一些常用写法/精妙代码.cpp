kk=kk&(kk-1);
//消除kk的二进制数的最后一个1
//kk的二进制数如101001011
//不断执行：10100101，1010010，10100，10，0 

kk=kk&(1<<(i-1));
//将kk的二进制型的数第i位0变1，1变0，适用于状态压缩的题
// 1<<j-1是将1左移j-1位，则只有第j位为1，1^1=0 , 1^0=1,用于只有两种状态的互相切换 
    
m<<n;   	m>>n; 	//左乘右除(整除)，分别表示为
//m*2^n     m/(2^n)  

//二进制算法,把二进制数转为10进制数 
int ans=0;
for(int i=0;i<n;i++){//a[i]从高位到低位记录二进制数 
	if(a[i]==0) ans*=2; 
	else ans=ans*2+1;//该为为1 
} 

for(int i=1; ;i++)
a[i]=a[i/2]*10+i%2;	
//可以说十进制数模拟的二进制数递增
//a[i]:1,10,11,100,101,110,111,1000,....

int x=z%3;
int y=z/3;
//一维变3*3的二维图形
//移动以后变为newx，newy，变回来只需int nz=newx+3*newy

数/10*10+i//把个位的数变为0再变为k 
数/100*100+i*10 +数%10
//	  修改十位  还原个位	 
//即修改指定一位的数 

a%b==a-a/b*b 

对于除法： 
n/m 	取平分后较小的数 
(n-1)/m+1	取平分后较大的数 

//对于数据：5 5
//			A 1 2
//			D 2 3 
scanf(" %c%d%d",&ch,&a,&b);//scanf中加入空格可跳过开头所有的空白符，这里可以直接跳过换行符

for(int i=1;i<=n;i++)
	printf("%d%c",x,i==n?'\n':' ');//一步到位

void build(node *root){
	...
	build(root->next);//创建树或者链表时可直接递归下一个节点 
}

//按位取反,计算机会将操作数对应的二进制表达式的每一个位进行取反运算，取反后得到的数就是按位取反的运算结果 
~n==-(n+1)//等效

if(n&1) ...//每一位都为1的时候才会1，可以用来判断n奇偶，1为奇数，0为偶数 
n^1//当n只为1或0时，0变1，1变0 
if(~n) //可以用来判断n是否为-1，适用于n初始化为-1的情况 

m^=n^=m^=n; //交换数值 

acos(-1) //求得Π值3.14.... 

max(a,max(b,c));//用函数套函数的方法可以得到几个数中最大的那个数 

//求((a-b)*(c-d))%mod,其中a,b,c,d为int型
1ll*(a-b+mod)*(c-d+mod)%mod//先将一项乘以1ll，表示将int类型变量转换为long long型变量，由long*int->long 
						 //还要在相减的式子里加mod，因为负数取余不常规 

//正整数n表示方法： 
n=2^k*m;//m为奇数且k>=0 
n=p1^a1*p2^a2*p3^a3...*pi^ai;//pi为质数，且pi<p(i+1)
n=2^0+2^1+...//二进制表示 

if(a[x]!=0) return a[x];
... 
return a[x]=sum;
在分治算法中，在递归函数中通常一个子问题的答案会经常调用，用数组a存下计算结果并返回 



