#include<stdio.h>
/*
 * 希尔排序
 * 1. 插入排序的升级版本，插入排序：把数组分为已排序序列和未排序序列，数组左边为已排序，右边为未排序，两重循环，每次拿出一个未排序数插入到已排序序列中
 * 2. 希尔排序：不再是只交换相邻的两个元素，而是将元素按一定间隔分为若干个序列，分别进行插入排序，设置的间隔越来越小，间隔越小分的序列就越少，直到间隔
 *    为1，也就是最后一次为简单插入排序
 * 3. 间隔就是一组增量序列，用来分割待排序列，每一个子序列排好序后选取下一个间隔，划分子序列再次排序
 *    比如 a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9] ，
 *    选取增量为5，则对{a[0],a[5]},{a[1],a[6]},{a[2],a[7]},{a[3],a[8]},{a[4],a[9]}这些子序列分别进行排序，
 *    然后选择增量1，此时的数组已经基本有序，对a[0]~a[9]排序就会少了很多交换，时间效率提高
 */
/**
 * 希尔排序
 * @param a 数组指针
 * @param n 数组元素个数
 */
void shellSort(int *a, int n) {
    int si, d, p, i;
    int tmp;
    // 序列增量，增量的不同，时间复杂度也不同
    int sedgewick[] = {929, 505, 209, 109, 41, 19, 5, 1, 0};

    for (si = 0; sedgewick[si] >= n; ++si); //初始的sedgewick[si]不能超过待排序列的长度

    for (d = sedgewick[si]; d > 0; d = sedgewick[++si]) //不断的减少间隔
        // 对每一子序列进行插入排序
        for (p = d; p < n; ++p) {
            tmp = a[p]; //当前序列中待插入的数据
            for (i = p; i >= d && a[i - d] > tmp; i -= d) //只在本序列中查找
                a[i] = a[i - d];
            a[i] = tmp;
        }
}

int main() {
    int n, a[100];
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    shellSort(a, n);
    for (int i = 0; i < n; ++i) {
        printf("%d ", a[i]);
    }
}

