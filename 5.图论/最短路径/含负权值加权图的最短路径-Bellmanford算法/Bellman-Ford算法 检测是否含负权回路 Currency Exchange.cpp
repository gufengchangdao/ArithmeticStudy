//Currency Exchange
/*
题意：n种货币，m个转换点，没个转换点只能把一种货币换为另一种货币，初始有第s种钱，总量为V,问可以通
	过不断转换，最后再回到s种金币总量增长吗 
Bellman - ford算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行
	松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出
	结果，否则就完成。
*/
#include<stdio.h>
using namespace std;
const int maxn=222;
double dis[maxn],v[maxn][2],V;
int d[maxn][2];		//边，d[i][0]->d[i][1]是一条边，v[i][0]是变成该种钱的汇率，v[i][1]是手续费 
int n,m,s;			//    d[i+1][0]->d[i+1][1]是他的反向边，v[i+1][0]、v[i+1][1]同理 

bool getans()
{
	dis[s]=V;//到达s顶点(换成s种金币)时的最大值 
	for(int i=0;i<n;i++){	//遍历n次 
		bool f=0;
		for(int j=0;j<(m<<1);j++)	//不是说从起点出发，而是直接每次遍历所有边 
			if(dis[d[j][1]]<(dis[d[j][0]]-v[j][1])*v[j][0])
				f=1,dis[d[j][1]]=(dis[d[j][0]]-v[j][1])*v[j][0];
		if(f==0) return 0; //存在s回到s时钱多(有解)的情况时，f永真 
	}
	return 1;	//能遍历n次不退出，那肯定有解了 
}

int main()
{
	scanf("%d%d%d%lf",&n,&m,&s,&V);
	for(int i=0;i<m;i++){
		scanf("%d%d%lf%lf%lf%lf",&d[i<<1][0],&d[i<<1][1],&v[i<<1][0],&v[i<<1][1],&v[i<<1|1][0],&v[i<<1|1][1]);
		d[i<<1|1][0]=d[i<<1][1];d[i<<1|1][1]=d[i<<1][0];
	}
	puts(getans()?"YES":"NO");
}

/*
为什么最少n-1遍循环呢？
	如果所有点成一个串，每一次遍历只会更新1条边，最少n-1次 
	或者说，每一次遍历都至少产生一个起点到某个顶点的最优解 
	那么如果没有负权回路的话，最多只能遍历n-1次，第n次一定没有到达某顶点的更优解
	该题有解的情况便是存在负权回路 
*/
